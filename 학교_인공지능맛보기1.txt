ㅁDT : data technology

ㅁ선별되어있는 데이터라면,즉 걸러진 데이터라면 인포메이션

걸러지지 않은 데이터라면 빅데이터라고 볼 수가 있다.

ㅁ머신러닝의 방법에는 여러 가지가 있지만, 그 중 크게 알려진 방법에는 아래와 같은 것이 있다.

-지도학습(supervised learning) : 문제와 정답을 모두 알려주며 학습시킴

-비지도학습(unsupervised learning) : 답은 알려주지 않고 학습시킴 (힌트 정도는 준다고 한다. 예를 들면, 10000장의 동물 사진에 대해 2가지 동물이 있다고만 알려주는 것.)

-강화학습(reinforcement learning) : 보상을 통해 보상은 최대화, 벌은 최소화하는 방향으로 행위를 강화함. (ex.게임 자동 플레이)

-딥러닝 : 인공신경망을 모방하는 방법. 정형 데이터(텍스트라거나..)에 사용하는 것보다는 비정형 데이터(사진 같은..)에 사용하는 것이 좋다.

ㅁ인공지능 활용례

자연어처리 - 딥러닝 활용 (구글 어시스턴트, chatGPT)

자연어처리 + 이미지처리 - CNN, GAN 활용 (DALL-E)

게임 인공지능 - 강화학습 활용 (구글의 반도체칩 설계에 활용)

ㅁ구글코랩(google colab) 
jupyter notebook을 웹에서 사용할 수 있음. 작성한 코드는 구글드라이브에 저장.
장점은 클라우드 컴퓨팅 서비스이므로 사양이 안 좋은 컴퓨터라고 할 지라도 무거운 작업을 돌리도록 할 수가 있다. 

ㅁ파이썬 팁

format 함수를 쓸 때 {0}, {1} 처럼 숫자를 쓰지 않아도 된다.

upper : 모두 영어 대문자 
lower : 모두 영어 소문자
capitalize : 맨앞 글자 영어 대문자로 바꿈
                                  
split은 분리가 되건 말건 무조건 list형태로 반환한다.

isalnum : 알파벳과 숫자로 이뤄져있는가?

리스트는 []로 표현한다.
리스트의 index()함수는 인자로 넣은 것을 찾아주는 함수다.
ex) list.index(1)은 값이 1인 index를 찾아준다.
islower : 소문자로 이뤄져 있는가

튜플에 담은 것은 튜플인 채로는 내부의 원소를 수정하거나 변경할 수가 없다.
튜플을 리스트로 캐스팅해서 수정한 후 튜플로 다시 캐스팅하면 되기는 한다.
튜플은 ()로 표현한다.

딕셔너리는 {}로 표현한다. (기본적으로.)
x in dict 이런 식으로 덩그러니 사용하면 key만 순회할 수 있다.
따라서 순회만을 위한 리스트나 튜플을 반환하는 함수가 존재한다.
dict.values() : value을 리스트 형태로 반환 (리스트는 아님.)
dict.keys() : key를 리스트 형태로 반환 (리스트는 아님)
dict.items() :  (key, value) 튜플을 리스트 형태로 반환. (리스트는 아님)

집합도 존재한다. set()으로 캐스팅해서 만드는 게 보통이다. 중복이 존재하지 않고 순서가 없다.
집합끼리의 연산은 다른 언어의 비트연산자로 할 수 있다.
집합을 표현할 때 {}로 표현한다.

ex) a&b : 교집합, a|b: 합집합, b-a:차집합

집합의 update 메소드는 여러 개 원소를 집합에 집어넣을 수 있다.
집합에 원소 하나를 추가할 때는 add를 사용한다

빈 객체, 빈 자료구조, 빈 문자열, 0은 false다. (bool 값으로 변환 시)

파이썬에서는 자바스크립트마냥 리스트같은 자료구조나 객체는 할당으로 복사를 시도하면 얕은 복사를 한다.
따라서 깊은 복사를 하고 싶으면 슬라이싱을 이용한다거나 별도의 방법을 사용해야한다.

팁으로 변수의 swap을 시도할 때는 a,b=b,a 이런 식으로만 해주면 된다.
(c=a; a=b; b=c; 이럴 필요는 없단 말이다.)

while문은 강사 曰 주로 얼마나 반복할 지 모를 때 사용한다고 했다.

강사 왈 파이썬의 모든 것은 클래스다.

클래스의 메소드를 구현할 때 첫 번째 매개변수는 무조건 존재해야하고, 그 매개변수는 self다.
그리고 self.(변수이름) 이런 식으로 클래스의 멤버 변수에 접근할 수 있다. 


ㅁ용어

데이터프레임 : 표 형태의 데이터를 말함.
시리즈 : 데이터프레임의 한 column을 이야기함.

csv : 데이터가 콤마단위로 구분되어 있는 파일.
tsv : 데이터가 탭문자단위로 구분되어 있는 파일.

ㅁpandas 라이브러리

이 모듈에는 tsv만을 위한 함수는 없다. tsv도 read_csv로 가져올 수 밖에 없다.
read_csv 함수의 매개변수에는 sep이란 일종의 옵션이 있다. 이걸로 구분자를 다르게 해서 tsv도 가져올 수 있다. (\t로 지정하면 됨.)

pandas의 info 함수로 읽어온 데이터프레임에 대한 정보를 볼 수가 있는데, 거기서 Dtype에 찍힌 object의 의미는 문자열 타입이란 뜻이다.

Non-Null Count에서 non-null이라고 뜬다면 누락이 없다는 뜻이다. 

어떤 열에 접근하기 위해서는 (일종의) id로 접근하면 된다.

ex)df["country"]

기본적으로 하나의 열에만 접근할 수 있지만, 여러 시리즈를 가지고 오기 위해서는 다음과 같이 쓰면 된다.

ex)df[["country","year"]]

어떤 행에 접근하는 방법에는 2가지가 있다.

loc은 이름으로 접근하고(인간 기준 인덱스), iloc은 순서대로 접근한다(컴퓨터 기준 인덱스).

df.loc[0] 이렇게 접근하면 0이라고 적힌 행을 가져온다.

df.iloc[0] 이렇게 접근하면 0번째 행을 가져온다.

그리고 df.loc[0]["country"] <=> df.loc[0,"country"] 이런 식으로 인덱싱하면 0이 적힌 행의 coutry 열에 접근할 수 있다.
(주의점으로, loc으로 접근할 때는 뭐든지 인간 기준의 인덱스로 접근해야한다. 즉, 열 접근 시에는 시리즈의 id(?) 값으로 접근해야한다는 말이다.) 

df.iloc[0,0]<=>df.iloc[0][0] 이런 식으로 인덱싱하면 0번째 행의 0번째 열의 데이터를 가져온다. 
(주의점으로, df.iloc[0,"country"] 처럼 접근하는 것을 불가능하다.)

loc과 iloc의 차이점은 슬라이싱에서 온다.
loc[0:2]는 0으로 적힌 것부터 2라고 적힌 행까지 가져오지만,
iloc[0:2]는 0번째부터 2-1번째 행까지 가져온다.

min(), max(), median()(중간값), std() (표준편차), describe() (요약 통계)
drop_duplicates() : 중복을 제거

이렇게 읽어온 데이터프레임은 시리즈 타입이다.
시리즈 타입에는 대수 연산이 가능하다. (대수 연산이 되는 타입에 한해서.)
시리즈 타입끼리 대수 연산을 하면 그 둘이 합쳐진 시리즈 타입이 반환된다.

시리즈 타입끼리도 더할 수는 있는데, 같은 행이름을 가진 행만 계산이 된다. 나머지 연산이 안된 행은 누락되어 버린다. (NaN)
만일 두 시리즈끼리 행 이름이 겹치는 게 없으면 행이름만 하나의 시리즈로 합쳐지고 값은 전부 누락된다. 

기존의 시리즈 타입에 대입을 하면 대체된다.

또, 데이터프레임[기존에 없던 열]=시리즈 이런 식으로 새로운 이름의 열을 만들 수도 있다.

(자바스크립트 객체에 프로퍼티 추가하고 수정하는 감각이랑 비슷하다.) 

데이터 프레임을 만들 수도 있다. pandas.DataFrame({ ... }) 이렇게 쓴다. 행이름은 index 매개변수를 설정하는 것으로 설정할 수가 있다. columns 매개변수를 설정하는 것으로 컬럼 순서를 바꿀 수 있다.

tip. 시리즈 타입은 pandas.Series([100,200,300]) 이런 식으로 직접 만들 수 있다. 또,  pandas.Series([100,200,300],index=["가","나","다"])
행이름도 정해줄 수가 있다.

시리즈 타입에 대고 비교 연산자를 사용해보도록 하자.
그러면 각각의 행에 대해 True/False 값이 쫘라락 반환되는 것을 볼 수 있다. 

ex ) a=df['year']>=2000; b=df['country'] =='Zimbabwe'; 

이렇게 비교한 값을 또 데이터프레임에 집어넣어보자.

df[a] => 이러면 year가 2000 이상인 행만 가져온다.

df[a&b] => 이러면 year가 2000 이상 AND country가 zimbabwe인 것만 가져온다.

df[a|b] = > 이러면 OR로 가져온다.

혹은 이렇게 비교 연산을 하는 게 비직관적이고 귀찮으면... a=df['year'].isin(["value"]) 이렇게 bool 값 차트를 알 수 있다.
(주의 : isin에 들어가는 것은 value이므로, 관련된 series를 뽑아낸 다음에 써야 의도한 대로 똑바로 행이 추출된다.) 

날짜를 다룰 때 문자열로 다루기 보다는 datetime으로 다루는 게 편하다. 그래서...

df['출생일']=pandas.to_datetime(df['출생일'],format='%Y-%m-%d') 이렇게 datetime으로 바꿀 수가 있다.

Y : 4자리 연도, y : 2자리 연도

datetime으로 바꿀 때 이점은 날짜의 덧셈, 뺄셈 연산이 가능해진다는 점과 연월일 추출이 가능하다는 점이다.

(datetime은 df['출생일']dt.year, dt.month 이렇게 뽑을 수 있다.)

데이터프레임이나 시리즈에는 groupby라는 집단화 함수가 존재한다. groupby(["ID"])를 넣으면 같은 ID를 가진 데이터끼리 묶어준다. 리스트로 ID를 묶어주면 그 기준으로 묶어준다.
ex ) df.groupby(['country','year']) 이렇게 하면 데이터가 나라를 1차적으로 분류하고, 나이로 2차적으로 분류한 집단이 된다. 다만 순서에는 주의하자. 1차적인 분류와 2차적 분류, n차적인 분류의 순서가 리스트의 순서에 의해 결정된다.)
(주의 : groupby로 얻은 것은 시리즈가 아니고, g_b=df.groupby(["ID1","ID2"]) 이렇게 접근한 것도 시리즈가 아니다. 시리즈에만 적용가능한 함수는 적용이 불가능함에 유의.)

그리고 plot함수를 사용하면 데이터를 matplob으로 간단히 시각화 해준다. (데이터프레임, 시리즈에 대해서.)

nunique() 함수는 데이터프레임이나 시리즈의 원소를 중복을 고려하여 count한다.

ㅁ 데이터 시각화

matplotlib , seaborn, pandas가 주로 데이터 시각화에 이용된다.

데이터프레임이나 시리즈를 엑셀로 변환하고 싶다면 to_excel() 함수를 사용하자. 인자는 파일명이다.

데이터 시각화를 하는 이유는 평균이나 표준편차로는 "이게 정말 전부 다 다른 데이터들인가?" 라는 판단을 하기 어려울 때가 있기 때문이다.

matplot.pyplot.figure()를 하면 figure 타입 변수를 만들 수 있다.

subplot(x,y,idx)으로 더 작은 그래프를 figure 내부에 만들 수 있다. tip. x,y,idx는 1부터 시작인 것 같다.

그리고 subplot 타입 변수의 메서드로 scatter(x=,y=)가 있는데, x,y를 정해주면 산점도로 그래프를 그려준다.
subplot 타입의 set_title 메서드로 작은 그래프의 이름을, figure 타입의 suptitle 메서드로 큰 도화지(?)의 이름을 붙일 수 있다.

일변량 그래프: 하나의 특성만을 표현 (어느 금액을 제일 많이 내나만 알 수 있었다.) ex 막대그래프(히스토그램)

이변량 그래프: 두 특성을 동시에 표현. 두 특성 간의 관계를 잘 알 수가 있음. (인원 수에 따른 팁의 관계를 알 수 있었다.) ex 산점도

subplot 타입의 메서드에서.. hist(데이터프레임 or 시리즈)를 통해서 막대그래프 형태로 그래프를 그릴 수가 있다. (ax.hist(df[[x,y]]) )
subplot 타입의 메서드에서...set_ylabel(), set_xlabel()을 통해서 x,y 값이 뭔지 적어줄 수가 있다.

tip) plt(matplot.pyplot)의 plot 함수는 인자가 두개인데...
plot(x=,y=)이다. 일단 하나만 적으면 기본적으로 y에 대입되고, 두 개를 적으면 x의 정의역을 정할 수가 있다.

ㅁ수치 계산

numpy 라이브러리를 사용한다.

range 함수는 정수단위로만 사용할 수 있다.
따라서...numpy.arange 함수를 사용해 step을 실수단위로 할 수가 있다.

이 arange 함수를 이용하면 그래프를 그리기가 쉬워진다.
x=numpy.arange(5,5,0.1)
y1=np.sin(x)
y2=x**2
plt.plot(y1)
plt.plot(y2)

이런식으로 하면 그래프가 잘 그려지는 걸 볼 수가 있다.